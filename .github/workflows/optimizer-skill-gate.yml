name: Optimizer Gate

on:
  pull_request:
    paths:
      - 'src/model/**'
      - 'src/hooks/useSimulationRunner.ts'
      - 'skills/depin-simulation-optimizer/**'
      - 'scripts/check_optimizer_report.ts'
      - 'package.json'
      - 'package-lock.json'
      - '.github/workflows/optimizer-skill-gate.yml'
  workflow_dispatch:

jobs:
  optimizer-gate:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    permissions:
      contents: read
      actions: read
      issues: read
    env:
      OPTIMIZER_GATE_REQUIRE_SCALE_DEGRADATION: "1"
      # Conservative starter floor to avoid near-zero break-even recommendations.
      # Tighten after observing 1-2 weeks of runs.
      OPTIMIZER_GATE_MIN_BREAK_EVEN_PRICE: "0.00025"
      # Done-marker defaults. Optional external counters can be injected via env when available.
      OPTIMIZER_DONE_REQUIRED_CONSECUTIVE_GREENS: "5"
      # "optimizer" scope blocks on model-quality criteria; use "dashboard" for full acceptance coverage blocking.
      OPTIMIZER_DONE_SCOPE: "optimizer"
      # Label names used for open high-severity regression counting.
      OPTIMIZER_DONE_HIGH_SEVERITY_LABELS: "P0,P1"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 24
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Collect done-marker evidence
        uses: actions/github-script@v7
        with:
          script: |
            const core = require('@actions/core');
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const workflowRef = process.env.GITHUB_WORKFLOW_REF || '';
            const workflowFile = workflowRef.includes('.github/workflows/')
              ? workflowRef.split('.github/workflows/')[1].split('@')[0]
              : 'optimizer-skill-gate.yml';
            const currentRunId = context.runId;
            const branch =
              context.payload.pull_request?.head?.ref ||
              process.env.GITHUB_REF_NAME;

            const requiredConsecutive = Number(process.env.OPTIMIZER_DONE_REQUIRED_CONSECUTIVE_GREENS || 5);
            const trackedLabels = (process.env.OPTIMIZER_DONE_HIGH_SEVERITY_LABELS || 'P0,P1')
              .split(',')
              .map((item) => item.trim().toLowerCase())
              .filter(Boolean);

            // 1) Consecutive green run estimate for this branch.
            try {
              const runs = await github.paginate(github.rest.actions.listWorkflowRuns, {
                owner,
                repo,
                workflow_id: workflowFile,
                branch,
                status: 'completed',
                per_page: 100
              });

              const sortedRuns = runs
                .filter((run) => run.id !== currentRunId)
                .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

              let priorSuccessStreak = 0;
              for (const run of sortedRuns) {
                if (run.conclusion === 'success') {
                  priorSuccessStreak += 1;
                  continue;
                }
                break;
              }

              // This workflow run is evaluating the same gate; add 1 as an "including current run" estimate.
              const estimatedIncludingCurrent = priorSuccessStreak + 1;
              core.exportVariable(
                'OPTIMIZER_GATE_CONSECUTIVE_GREEN_RUNS',
                String(estimatedIncludingCurrent)
              );
              core.info(
                `Consecutive green runs (estimated, including current): ${estimatedIncludingCurrent} (required >= ${requiredConsecutive}, branch=${branch}, workflow=${workflowFile})`
              );
            } catch (error) {
              core.warning(`Could not derive consecutive green runs: ${error.message}`);
            }

            // 2) Open P0/P1 issue count.
            try {
              const openItems = await github.paginate(github.rest.issues.listForRepo, {
                owner,
                repo,
                state: 'open',
                per_page: 100
              });

              let openHighSeverity = 0;
              for (const item of openItems) {
                // Skip pull requests; this criterion tracks issue regressions.
                if (item.pull_request) {
                  continue;
                }

                const labelNames = (item.labels || [])
                  .map((label) =>
                    typeof label === 'string' ? label : (label?.name || '')
                  )
                  .map((name) => name.trim().toLowerCase())
                  .filter(Boolean);

                if (labelNames.some((name) => trackedLabels.includes(name))) {
                  openHighSeverity += 1;
                }
              }

              core.exportVariable('OPTIMIZER_GATE_OPEN_P0P1', String(openHighSeverity));
              core.info(
                `Open high-severity issues=${openHighSeverity} (labels=${trackedLabels.join(', ')})`
              );
            } catch (error) {
              core.warning(`Could not derive open P0/P1 count: ${error.message}`);
            }

      - name: Run optimizer diagnostics + gate
        run: npm run ci:optimizer

      - name: Generate priority action report
        if: always()
        run: node --experimental-strip-types scripts/generate_ci_priority_actions.ts --profile ono_v3_calibrated --mode quick

      - name: Upload optimizer reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: optimizer-skill-reports
          path: output/skill_reports/
          if-no-files-found: warn
